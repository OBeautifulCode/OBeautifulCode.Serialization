// --------------------------------------------------------------------------------------------------------------------
// <copyright file="RoundtripSerializationExtensions.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Serialization.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Serialization.Recipes
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    using OBeautifulCode.Assertion.Recipes;
    using OBeautifulCode.Reflection.Recipes;
    using OBeautifulCode.Representation.System;
    using OBeautifulCode.Serialization.Bson;
    using OBeautifulCode.Serialization.Json;
    using OBeautifulCode.Serialization.PropertyBag;
    using OBeautifulCode.Type.Recipes;

    using static System.FormattableString;

    /// <summary>
    /// Verifies that the object to serialize is equal to the resulting deserialized object.
    /// </summary>
    /// <typeparam name="T">The type being tested.</typeparam>
    /// <param name="yieldedDescribedSerialization">The results of serialization.</param>
    /// <param name="deserializedObject">The deserialized object.</param>
#if !OBeautifulCodeSerializationRecipesProject
    [System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Serialization.Recipes", "See package version number")]
    internal
#else
    public
#endif
    delegate void RoundtripSerializationVerification<in T>(
        DescribedSerialization yieldedDescribedSerialization,
        T deserializedObject);

    /// <summary>
    /// Extension methods for roundtrip serialization testing.
    /// </summary>
#if !OBeautifulCodeSerializationRecipesProject
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Serialization.Recipes", "See package version number")]
    internal
#else
    public
#endif
    static partial class RoundtripSerializationExtensions
    {
        /// <summary>
        /// Test roundtrip serialization, asserting that the expected/provided value is equal to the deserialized value using
        /// <see cref="Verifications.BeEqualTo{T}(AssertionTracker, T, string, ApplyBecause, System.Collections.IDictionary)"/>.
        /// Use the following the serialization configuration wrappers for the type being tested:
        /// <see cref="TypesToRegisterBsonSerializationConfiguration{T}"/>
        /// <see cref="TypesToRegisterJsonSerializationConfiguration{T}"/>
        /// <see cref="TypesToRegisterPropertyBagSerializationConfiguration{T}"/>.
        /// </summary>
        /// <typeparam name="T">The type being tested.</typeparam>
        /// <param name="expected">The value to serialize, which should be equal to the resulting deserialized object.</param>
        /// <param name="testBson">Optional value indicating whether to test serialization to/from BSON.  DEFAULT is true.</param>
        /// <param name="testJson">Optional value indicating whether to test serialization to/from JSON.  DEFAULT is true.</param>
        /// <param name="testPropertyBag">Option value indicating whether to test serialization to/from a Property Bag.  DEFAULT is false.</param>
        /// <param name="formats">The serialization formats to test.</param>
        public static void RoundtripSerializeUsingTypesToRegisterConfigWithBeEqualToAssertion<T>(
            this T expected,
            bool testBson = true,
            bool testJson = true,
            bool testPropertyBag = false,
            IReadOnlyCollection<SerializationFormat> formats = null)
        {
            expected.RoundtripSerializeWithBeEqualToAssertion(
                typeof(TypesToRegisterBsonSerializationConfiguration<T>),
                typeof(TypesToRegisterJsonSerializationConfiguration<T>),
                typeof(TypesToRegisterPropertyBagSerializationConfiguration<T>),
                testBson,
                testJson,
                testPropertyBag,
                formats);
        }

        /// <summary>
        /// Test roundtrip serialization, asserting that the expected/provided value is equal to the deserialized value using
        /// <see cref="Verifications.BeEqualTo{T}(AssertionTracker, T, string, ApplyBecause, System.Collections.IDictionary)"/>,
        /// with the serialization configuration type(s) specified.
        /// </summary>
        /// <typeparam name="T">The type being tested.</typeparam>
        /// <param name="expected">The value to serialize, which should be equal to the resulting deserialized object.</param>
        /// <param name="bsonSerializationConfigurationType">Optional type of the serialization configuration to use for BSON testing.  DEFAULT is null; <see cref="NullBsonSerializationConfiguration"/> will be used.</param>
        /// <param name="jsonSerializationConfigurationType">Optional type of the serialization configuration to use for JSON testing.  DEFAULT is null; <see cref="NullJsonSerializationConfiguration"/> will be used.</param>
        /// <param name="propertyBagSerializationConfigurationType">Optional type of the serialization configuration to use for Property Bag testing.  DEFAULT is null; <see cref="NullPropertyBagSerializationConfiguration"/> will be used.</param>
        /// <param name="testBson">Optional value indicating whether to test serialization to/from BSON.  DEFAULT is true.</param>
        /// <param name="testJson">Optional value indicating whether to test serialization to/from JSON.  DEFAULT is true.</param>
        /// <param name="testPropertyBag">Option value indicating whether to test serialization to/from a Property Bag.  DEFAULT is false.</param>
        /// <param name="formats">The serialization formats to test.</param>
        public static void RoundtripSerializeWithBeEqualToAssertion<T>(
            this T expected,
            Type bsonSerializationConfigurationType = null,
            Type jsonSerializationConfigurationType = null,
            Type propertyBagSerializationConfigurationType = null,
            bool testBson = true,
            bool testJson = true,
            bool testPropertyBag = false,
            IReadOnlyCollection<SerializationFormat> formats = null)
        {
            RoundtripSerializeWithCallbackVerification(
                expected,
                (yieldedDescribedSerialization, deserializedObject) => deserializedObject.AsTest().Must().BeEqualTo(expected),
                bsonSerializationConfigurationType,
                jsonSerializationConfigurationType,
                propertyBagSerializationConfigurationType,
                testBson,
                testJson,
                testPropertyBag,
                formats);
        }

        /// <summary>
        /// Test roundtrip serialization, asserting that the expected/provided value is equal to the deserialized value using
        /// the specified callback, with the serialization configuration type(s) specified.
        /// </summary>
        /// <typeparam name="T">The type being tested.</typeparam>
        /// <param name="expected">The value to serialize, which should be equal to the resulting deserialized object.</param>
        /// <param name="verificationCallback">Callback to verify that the expected/provided value is equal to the deserialized value.</param>
        /// <param name="bsonSerializationConfigurationType">Optional type of the serialization configuration to use for BSON testing.  DEFAULT is null; <see cref="NullBsonSerializationConfiguration"/> will be used.</param>
        /// <param name="jsonSerializationConfigurationType">Optional type of the serialization configuration to use for JSON testing.  DEFAULT is null; <see cref="NullJsonSerializationConfiguration"/> will be used.</param>
        /// <param name="propertyBagSerializationConfigurationType">Optional type of the serialization configuration to use for Property Bag testing.  DEFAULT is null; <see cref="NullPropertyBagSerializationConfiguration"/> will be used.</param>
        /// <param name="testBson">Optional value indicating whether to test serialization to/from BSON.  DEFAULT is true.</param>
        /// <param name="testJson">Optional value indicating whether to test serialization to/from JSON.  DEFAULT is true.</param>
        /// <param name="testPropertyBag">Option value indicating whether to test serialization to/from a Property Bag.  DEFAULT is false.</param>
        /// <param name="formats">The serialization formats to test.</param>
        public static void RoundtripSerializeWithCallbackVerification<T>(
            this T expected,
            RoundtripSerializationVerification<T> verificationCallback,
            Type bsonSerializationConfigurationType = null,
            Type jsonSerializationConfigurationType = null,
            Type propertyBagSerializationConfigurationType = null,
            bool testBson = true,
            bool testJson = true,
            bool testPropertyBag = false,
            IReadOnlyCollection<SerializationFormat> formats = null)
        {
            formats = formats ?? new[] { SerializationFormat.String, SerializationFormat.Binary };

            formats.AsArg().Must().NotBeNullNorEmptyEnumerable();

            var serializerRepresentations = new List<SerializerRepresentation>();

            if (testBson)
            {
                var serializerDescription = new SerializerRepresentation(SerializationKind.Bson, bsonSerializationConfigurationType?.ToRepresentation());

                serializerRepresentations.Add(serializerDescription);
            }

            if (testJson)
            {
                var serializerRepresentation = new SerializerRepresentation(SerializationKind.Json, jsonSerializationConfigurationType?.ToRepresentation());

                serializerRepresentations.Add(serializerRepresentation);
            }

            if (testPropertyBag)
            {
                var serializerDescription = new SerializerRepresentation(SerializationKind.PropertyBag, propertyBagSerializationConfigurationType?.ToRepresentation());

                serializerRepresentations.Add(serializerDescription);
            }

            if (!serializerRepresentations.Any())
            {
                throw new InvalidOperationException("No serializers are being tested.");
            }

            Func<SerializerRepresentation, SerializationFormat, object, DescribedSerialization> serializeFunc = Serialize;

            Func<DescribedSerialization, T> deserializeFunc = Deserialize<T>;

            Func<SerializerRepresentation, SerializationFormat, object, Tuple<DescribedSerialization, T>> serializeAndDeserializeFunc = SerializeAndDeserialize<T>;

            foreach (var serializerRepresentation in serializerRepresentations)
            {
                foreach (var format in formats)
                {
                    // serialize in a new app domain
                    var describedSerialization = serializeFunc.ExecuteInNewAppDomain(serializerRepresentation, format, expected);

                    // deserialize in a new app domain
                    var actual = deserializeFunc.ExecuteInNewAppDomain(describedSerialization);

                    try
                    {
                        verificationCallback(describedSerialization, actual);
                    }
                    catch (Exception ex)
                    {
                        throw new InvalidOperationException(Invariant($"Failed to roundtrip specified object to/from {serializerRepresentation.SerializationKind} {format} using {serializerRepresentation.SerializationConfigType.ResolveFromLoadedTypes().ToStringReadable()} when serializing in a new AppDomain and deserializing in a new AppDomain.  Deserialized object is: {actual}."), ex);
                    }

                    // serialize and deserialize in the same, new app domain
                    var describedSerializationAndActual = serializeAndDeserializeFunc.ExecuteInNewAppDomain(serializerRepresentation, format, expected);

                    try
                    {
                        verificationCallback(describedSerializationAndActual.Item1, describedSerializationAndActual.Item2);
                    }
                    catch (Exception ex)
                    {
                        throw new InvalidOperationException(Invariant($"Failed to roundtrip specified object to/from {serializerRepresentation.SerializationKind} {format} using {serializerRepresentation.SerializationConfigType.ResolveFromLoadedTypes().ToStringReadable()} when serializing and deserializing in the same, new AppDomain.  Deserialized object is: {actual}."), ex);
                    }
                }
            }
        }

        private static DescribedSerialization Serialize(
            SerializerRepresentation serializerRepresentation,
            SerializationFormat serializationFormat,
            object objectToSerialize)
        {
            var result = objectToSerialize.ToDescribedSerialization(serializerRepresentation, serializationFormat);

            return result;
        }

        private static T Deserialize<T>(
            DescribedSerialization describedSerialization)
        {
            var result = describedSerialization.DeserializePayload<T>();

            return result;
        }

        private static Tuple<DescribedSerialization, T> SerializeAndDeserialize<T>(
            SerializerRepresentation serializerRepresentation,
            SerializationFormat serializationFormat,
            object objectToSerialize)
        {
            var describedSerialization = objectToSerialize.ToDescribedSerialization(serializerRepresentation, serializationFormat);

            var actual = describedSerialization.DeserializePayload<T>();

            // note that we cannot return a ValueTuple (DescribedSerialization DescribedSerialization, T actual)
            // here because ValueTuple is not [Serializable]
            var result = new Tuple<DescribedSerialization, T>(describedSerialization, actual);

            return result;
        }
    }
}
